/**
 * The code generated by the parser generate will only turn
 * its input into a raw parse tree. This file will convert the
 * raw parse tree into its AST.
 *
 * * The interpreter should not be dependent on anything from
 *   the parser generator. All parse tree nodes should be mapped
 *   to some cleaner AST node.
 */

import antlr4 from 'https://cdn.jsdelivr.net/npm/antlr4@4.13.1/+esm'
import WDTPDLexer from './WDTPDLexer.js'
import WDTPDParser from './WDTPDParser.js'

function getRawContent(node, rawInput) {
  let start, stop
  if (node.symbol) {
    start = node.symbol.start
    stop = node.symbol.stop
  } else {
    // Is a rule, contains multiple tokens
    start = node.start.start
    stop = node.stop.stop
  }
  return rawInput.substring(start, stop + 1)
}

// Expressions

function parseArgumentList(argList, rawInput) {
  return argList.children
    .filter((_, i) => i % 2 == 0)
    .map((a) => parseExpression(a, rawInput));
}

function parseExpression(expr, rawInput) {
  while (
    expr.children &&
    expr.children.length == 1 &&
    expr.children[0].ruleIndex &&
    expr.ruleIndex != WDTPDParser.RULE_reference
  ) {
    expr = expr.children[0]
  }

  if (expr.ruleIndex == WDTPDParser.RULE_reference) {
    return parseReference(expr, rawInput);
  }

  if (
    expr.ruleIndex == WDTPDParser.RULE_literal ||
    expr.ruleIndex == WDTPDParser.RULE_number
  ) {
    let rawValue = getRawContent(expr, rawInput)
    return eval(rawValue)
  }

  if (expr.ruleIndex == WDTPDParser.RULE_function_call) {
    return {
      type: 'function_call',
      func_name: getRawContent(expr.children[0], rawInput),
      param: parseExpression(expr.children[2], rawInput),
    }
  }

  if (expr.ruleIndex == WDTPDParser.RULE_array_reference) {
    return expr
  }
  if (expr.ruleIndex == WDTPDParser.RULE_str_slice) {
    let id = expr.children[0]
    let i = expr.children[2]
    let j = null
    if (expr.children.length > 3) {
      j = expr.children[4]
    }
    return {
      type: 'str_slice',
      id: getRawContent(id, rawInput),
      i: parseExpression(i, rawInput),
      j: j == null ? null : parseExpression(j, rawInput),
    }
  }

  if (expr.ruleIndex == WDTPDParser.RULE_paren_expr) {
    return parseExpression(expr.children[1], rawInput)
  }

  // Just use the raw symbol for unary and binary operations
  if (expr.ruleIndex == WDTPDParser.RULE_unary_expr) {
    let symbol = expr.children[0]
    let val = expr.children[1]
    return {
      type: 'unary_expr',
      operation: getRawContent(symbol, rawInput),
      operand: parseExpression(val, rawInput),
    }
  }

  let binaryOperations = [
    WDTPDParser.RULE_conditional_or_expr,
    WDTPDParser.RULE_conditional_and_expr,
    WDTPDParser.RULE_and_expr,
    WDTPDParser.RULE_or_expr,
    WDTPDParser.RULE_relational_expr,
    WDTPDParser.RULE_equality_expr,
    WDTPDParser.RULE_additive_expr,
    WDTPDParser.RULE_multiplicative_expr,
    WDTPDParser.RULE_exponent_expr,
  ]
  if (binaryOperations.includes(expr.ruleIndex)) {
    let l = expr.children[0]
    let symbol = expr.children[1]
    let r = expr.children[2]
    return {
      type: 'binary_expr',
      l: parseExpression(l, rawInput),
      operation: getRawContent(symbol, rawInput),
      r: parseExpression(r, rawInput),
    }
  }

  let output = getRawContent(expr, rawInput)
  console.error(
    'WDTPDAST::parseExpression unimplemented',
    output,
    expr.ruleIndex,
    expr,
  )
  return output
}

// Assignments

function parseReferenceList(refs, rawInput) {
  return refs.children
    .filter((_, i) => i % 2 == 0)
    .map((r) => parseReference(r, rawInput));
}

function parseReference(node, rawInput) {
  if (node.ruleIndex == WDTPDParser.RULE_reference) {
    node = node.children[0];
  }
  if (node.ruleIndex == WDTPDParser.RULE_id) {
    return {
      type: 'id',
      id: getRawContent(node, rawInput).toUpperCase(),
    }
  }
  if (node.ruleIndex == WDTPDParser.RULE_array_reference) {
    let id = node.children[0]
    let index = node.children[2]
    return {
      type: 'array_reference',
      id: getRawContent(id, rawInput).toUpperCase(),
      index: parseArgumentList(index, rawInput),
    }
  }
}

function parseAssignment(assignment, rawInput) {
  let leftHandSide = assignment.children[0].children[0];
  let expression = assignment.children[2];
  return {
    type: 'assignment',
    leftHandSide: parseReference(leftHandSide, rawInput),
    expression: parseExpression(expression, rawInput),
  }
}

function parseAssignmentList(assignmentList, rawInput) {
  let assignments = assignmentList.children
    .filter(n => n.ruleIndex) // Filter out ":" nodes
    .map(a => parseAssignment(a, rawInput))
  return {
    type: 'assignment_list',
    children: assignments,
  }
}

// Control Logic

function parseIf(ifStmt, rawInput) {
  let subStmt = ifStmt.children[0]
  let condition = subStmt.children[1]
  let onTrueBody, onFalseBody
  if (
    subStmt.ruleIndex == WDTPDParser.RULE_single_line_if_stmt &&
    subStmt.children.length == 4
  ) {
    onTrueBody = subStmt.children[3]
    onFalseBody = null
  } else if (
    subStmt.ruleIndex == WDTPDParser.RULE_single_line_if_stmt &&
    subStmt.children.length == 6
  ) {
    onTrueBody = subStmt.children[3]
    onFalseBody = subStmt.children[5]
  } else if (
    subStmt.ruleIndex == WDTPDParser.RULE_multi_line_if_stmt &&
    subStmt.children.length == 6
  ) {
    onTrueBody = subStmt.children[4]
    onFalseBody = null
  } else if (
    subStmt.ruleIndex == WDTPDParser.RULE_multi_line_if_stmt &&
    subStmt.children.length == 9
  ) {
    onTrueBody = subStmt.children[4]
    onFalseBody = subStmt.children[8]
  } else {
    throw ('WDTPDAST::parseIf unexpected subrule', subStmt.ruleIndex)
  }
  return {
    type: 'if_stmt',
    condition: parseExpression(condition, rawInput),
    onTrueBody: parseStmts(onTrueBody, rawInput),
    onFalseBody: onFalseBody == null ? [] : parseStmts(onFalseBody, rawInput),
  }
}

function parseForLoop(forLoop, rawInput) {
  let init = forLoop.children[1]
  let stopCond = forLoop.children[3]
  let step, stmtList
  if (forLoop.children.length == 7) {
    // No STEP clause
    step = null
    stmtList = forLoop.children[5]
  } else if (forLoop.children.length == 9) {
    step = forLoop.children[5]
    stmtList = forLoop.children[7]
  } else {
    throw 'WDTPDAST::parseForLoop Unexpected number of children!'
  }
  return {
    type: 'for_loop',
    init: parseAssignment(init, rawInput),
    stopCond: parseExpression(stopCond, rawInput),
    step: step == null ? null : parseExpression(step, rawInput),
    stmts: parseStmts(stmtList, rawInput),
  }
}

function parseWhileLoop(whileLoop, rawInput) {
  let condition = whileLoop.children[1]
  let stmtList = whileLoop.children[3]
  return {
    type: 'while_loop',
    condition: parseExpression(condition, rawInput),
    stmts: parseStmts(stmtList, rawInput),
  }
}

// IO

function parseInput(stmt, rawInput) {
  let inputReferences = stmt.children[1];
  return {
    type: 'input',
    refs: parseReferenceList(inputReferences, rawInput)
  }
}

function parseOutput(stmt, rawInput) {
  let outputExprs = stmt.children.slice(1)[0]
  return {
    type: 'output',
    exprs: parseArgumentList(outputExprs, rawInput),
  }
}

// Statements

function parseStmt(stmt, rawInput) {
  switch (stmt.ruleIndex) {
    case WDTPDParser.RULE_stmt:
      return parseStmt(stmt.children[0], rawInput)

    case WDTPDParser.RULE_assignment_list:
      return parseAssignmentList(stmt, rawInput)
    case WDTPDParser.RULE_while_stmt:
      return parseWhileLoop(stmt, rawInput)
    case WDTPDParser.RULE_for_loop_stmt:
      return parseForLoop(stmt, rawInput)
    case WDTPDParser.RULE_if_stmt:
      return parseIf(stmt, rawInput)
    case WDTPDParser.RULE_input:
      return parseInput(stmt, rawInput)
    case WDTPDParser.RULE_output:
      return parseOutput(stmt, rawInput)
    default:
      console.error('WDTPDAST::parseStmt unimplemented', stmt.ruleIndex)
  }
}

function parseStmts(stmts, rawInput) {
  if (stmts.ruleIndex == WDTPDParser.RULE_stmt) {
    return [ parseStmt(stmts, rawInput) ]
  } else if (stmts.ruleIndex == WDTPDParser.RULE_stmt_list) {
    stmts = stmts.children
    return stmts
      .filter(r => r.ruleIndex == WDTPDParser.RULE_stmt)
      .map(s => parseStmt(s, rawInput))
  }
  throw "WDTPDAST::parseStmts unexpected input", stmts.ruleIndex
}

/**
 * Recursively transforms an ANTLR parse tree into a more consumable AST
 */
function parseTree2AST(root, rawInput) {
  let output = root
  switch (root.ruleIndex) {
    case WDTPDParser.RULE_prog:
      let stmtList = root.children[0]
      output = parseStmts(stmtList, rawInput)
      break
    case WDTPDParser.RULE_stmt:
      output = parseStmt(root, rawInput)
      break
    default:
      console.error('WDTPDAST::parseTree2AST unimplemented', root.ruleIndex)
  }
  return output
}

export default function parse(input) {
  const chars = new antlr4.InputStream(input)
  const lexer = new WDTPDLexer(chars)
  const tokens = new antlr4.CommonTokenStream(lexer)
  const parser = new WDTPDParser(tokens)
  const parseTree = parser.prog()
  const ast = parseTree2AST(parseTree, input)
  return ast
}
