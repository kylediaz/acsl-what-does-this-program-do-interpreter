/**
 * The code generated by the parser generate will only turn
 * its input into a raw parse tree. This file will convert the
 * raw parse tree into its AST. 
 * 
 * * The interpreter should not be dependent on anything from
 *   the parser generator. All parse tree nodes should be mapped
 *   to some cleaner AST node.
 */

import antlr4 from 'https://cdn.jsdelivr.net/npm/antlr4@4.13.1/+esm';
import WDTPDLexer from './WDTPDLexer.js';
import WDTPDParser from './WDTPDParser.js';

function getRawContent(node, rawInput) {
    let start, stop;
    if (node.symbol) {
        start = node.symbol.start;
        stop = node.symbol.stop;
    } else { // Is a rule, contains multiple tokens
        start = node.start.start;
        stop = node.stop.stop;
    }
    return rawInput.substring(start, stop+1);
}

// Expressions

function parseExpression(expr, rawInput) {
    while (expr.children && expr.children.length == 1 && expr.children[0].ruleIndex) {
        expr = expr.children[0];
    }

    if (expr.ruleIndex == WDTPDParser.RULE_id) {
        return {
            type: "id",
            id: getRawContent(expr, rawInput)
        };
    }

    if (expr.ruleIndex == WDTPDParser.RULE_literal || expr.ruleIndex == WDTPDParser.RULE_number) {
        let rawValue = getRawContent(expr, rawInput);
        return eval(rawValue);
    }

    if (expr.ruleIndex == WDTPDParser.RULE_function_call) {
        return {
            type: "function_call",
            func_name: getRawContent(expr.children[0], rawInput),
            param: parseExpression(expr.children[2], rawInput)
        }
    }

    if (expr.ruleIndex == WDTPDParser.RULE_array_reference) {
        return expr;
    }
    if (expr.ruleIndex == WDTPDParser.RULE_str_slice) {
        let id = expr.children[0];
        let i = expr.children[2];
        let j = null;
        if (expr.children.length > 3) {
            j = expr.children[4];
        }
        return {
            type: "str_slice",
            id: getRawContent(id, rawInput),
            i: parseExpression(i, rawInput),
            j: j == null ? null : parseExpression(j, rawInput)
        }
    }

    // Just use the raw symbol for unary and binary operations
    if (expr.ruleIndex == WDTPDParser.RULE_unary_expr) {
        let symbol = expr.children[0];
        let val = expr.children[1];
        return {
            type: "unary_expr",
            operation: getRawContent(symbol, rawInput),
            operand: parseExpression(val, rawInput),
        }
    }
    
    let binaryOperations = [
        WDTPDParser.RULE_conditional_or_expr, WDTPDParser.RULE_conditional_and_expr,
        WDTPDParser.RULE_and_expr, WDTPDParser.RULE_or_expr, 
        WDTPDParser.RULE_relational_expr, WDTPDParser.RULE_equality_expr,
        WDTPDParser.RULE_additive_expr, WDTPDParser.RULE_multiplicative_expr,
        WDTPDParser.RULE_exponent_expr,
    ];
    if (binaryOperations.includes(expr.ruleIndex)) {
        let l = expr.children[0];
        let symbol = expr.children[1];
        let r = expr.children[2];
        return {
            type: "binary_expr",
            l: parseExpression(l, rawInput),
            operation: getRawContent(symbol, rawInput),
            r: parseExpression(r, rawInput)
        }
    }

    let output = getRawContent(expr, rawInput);
    console.error("WDTPDAST::parseExpression unimplemented", output, expr.ruleIndex, expr);
    return output;
}

// Assignments

function parseLeftHandSide(node, rawInput) {
    if (node.ruleIndex == WDTPDParser.RULE_id) {
        return {
            type: "id",
            id: getRawContent(node, rawInput)
        }
    }
    if (node.ruleIndex == WDTPDParser.RULE_array_reference) {
        let id = node.children[3];
        let index = node.children[5];
        return {
            type: "array_reference",
            id: getRawContent(id, rawInput),
            index: parseExpression(index)
        }
    }
}

function parseAssignment(assignment, rawInput) {
    let leftHandSide = assignment.children[0];
    let expression = assignment.children[2];
    return {
        type: "assignment",
        leftHandSide: parseLeftHandSide(leftHandSide, rawInput),
        expression: parseExpression(expression, rawInput)
    }
}

function parseAssignmentList(assignmentList, rawInput) {
    let assignments = assignmentList.children
            .filter((n) => n.ruleIndex) // Filter out ":" nodes
            .map((a) => parseAssignment(a, rawInput));
    return {
        type: "assignment_list",
        children: assignments
    };
}

// Control Logic

function parseIf(ifStmt, rawInput) {
    let condition = ifStmt.children[1];
    let stmtList = ifStmt.children[3];
    return {
        type: "if_stmt",
        condition: parseExpression(condition, rawInput),
        stmts: parseStmts(stmtList, rawInput)
    }
}

function parseForLoop(forLoop, rawInput) {
    let init = forLoop.children[1];
    let stopCond = forLoop.children[3];
    let step, stmtList;
    if (forLoop.children.length == 6) { // No STEP clause
        step = null;
        stmtList = forLoop.children[4];
    } else {
        step = forLoop.children[5];
        stmtList = forLoop.children[6];
    }
    return {
        type: "for_loop",
        init: parseAssignment(init, rawInput),
        stopCond: parseExpression(stopCond, rawInput),
        step: step == null ? null : parseExpression(step, rawInput),
        stmts: parseStmts(stmtList, rawInput)
    }
}

function parseWhileLoop(whileLoop, rawInput) {
    let condition = whileLoop.children[1];
    let stmtList = whileLoop.children[3];
    return {
        type: "while_loop",
        condition: parseExpression(condition, rawInput),
        stmts: parseStmts(stmtList, rawInput)
    }
}

// IO

function parseInput(stmt, rawInput) {

}

function parseOutput(stmt, rawInput) {
    let outputExprs = stmt.children.slice(1);
    return {
        type: "output",
        exprs: outputExprs.map((expr) => parseExpression(expr, rawInput))
    };
}

// Statements

function parseStmt(stmt, rawInput) {
    switch (stmt.ruleIndex) {
        case WDTPDParser.RULE_stmt:
            return parseStmt(stmt.children[0], rawInput);

        case WDTPDParser.RULE_assignment_list:
            return parseAssignmentList(stmt, rawInput);
        case WDTPDParser.RULE_while_stmt:
            return parseWhileLoop(stmt, rawInput);
        case WDTPDParser.RULE_for_loop_stmt:
            return parseForLoop(stmt, rawInput);
        case WDTPDParser.RULE_if_stmt:
            return parseIf(stmt, rawInput);
        case WDTPDParser.RULE_input:
            return parseInput(stmt, rawInput);
        case WDTPDParser.RULE_output:
            return parseOutput(stmt, rawInput)
        default:
            console.error("WDTPDAST::parseStmt unimplemented", stmt.ruleIndex);
    }
}

function parseStmts(stmtList, rawInput) {
    let stmts = stmtList.children;
    return stmts.map((s) => parseStmt(s, rawInput));
}

/**
 * Recursively transforms an ANTLR parse tree into a more consumable AST
 */
function parseTree2AST(root, rawInput) {
    let output = root;
    switch (root.ruleIndex) {
        case WDTPDParser.RULE_prog:
            let stmtList = root.children[0];
            output = parseStmts(stmtList, rawInput);
            break;
        case WDTPDParser.RULE_stmt:
            output = parseStmt(root, rawInput);
            break;
        default:
            console.error("WDTPDAST::parseTree2AST unimplemented", root.ruleIndex);
    }
    return output;
}

export default function parse(input) {
    const chars = new antlr4.InputStream(input);
    const lexer = new WDTPDLexer(chars);
    const tokens = new antlr4.CommonTokenStream(lexer);
    const parser = new WDTPDParser(tokens);
    const parseTree = parser.prog();
    const ast = parseTree2AST(parseTree, input);
    return ast;
}